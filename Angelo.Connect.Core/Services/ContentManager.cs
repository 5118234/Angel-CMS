using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;

using Angelo.Connect.Data;
using Angelo.Connect.Models;
using Angelo.Connect.Widgets;
using Angelo.Connect.Rendering;

namespace Angelo.Connect.Services
{
    public class ContentManager
    {
        private ConnectDbContext _connectDb;
        private WidgetProvider _widgetProvider;

        public ContentManager(ConnectDbContext connectDb, WidgetProvider widgetProvider)
        {
            _connectDb = connectDb;
            _widgetProvider = widgetProvider;
        }

        public async Task<IEnumerable<ContentVersion>> GetVersionHistory(string contentType, string contentId)
        {
            return await _connectDb.ContentVersions.Where(x => 
                    x.ContentType == contentType
                    && x.ContentId == contentId
                )
                .OrderByDescending(x => x.Created)
                .ToListAsync();
        }

        public async Task<IEnumerable<ContentVersion>> GetVersionHistory(string contentType, string contentId, ContentStatus status)
        {
            return await _connectDb.ContentVersions.Where(x => 
                x.ContentType == contentType
                && x.ContentId == contentId 
                && x.Status == status
            ).ToListAsync();
        }

        public async Task<ContentVersion> GetPublishedVersionInfo(string contentType, string contentId)
        {
            return await _connectDb.ContentVersions
                .FirstOrDefaultAsync(x => 
                    x.ContentType == contentType
                    && x.ContentId == contentId 
                    && x.Status == ContentStatus.Published
                );
        }

        public async Task<ContentVersion> GetLatestDraftVersionInfo(string contentType, string contentId)
        {
            return await _connectDb.ContentVersions
                .OrderByDescending(x => x.VersionCode)
                .FirstOrDefaultAsync(x =>
                    x.ContentType == contentType
                    && x.ContentId == contentId
                    && x.Status == ContentStatus.Draft
                );
        }

        public async Task<ContentVersion> GetVersionInfo(string contentId, string versionCode)
        {
            return await _connectDb.ContentVersions
                 .FirstOrDefaultAsync(x =>
                    x.ContentId == contentId
                    && x.VersionCode == versionCode
                );
        }

        public async Task<ContentVersion> GetVersionInfo(string contentType, string contentId, string versionCode)
        {
            return await _connectDb.ContentVersions
                 .FirstOrDefaultAsync(x =>
                    x.ContentType == contentType
                    && x.ContentId == contentId
                    && x.VersionCode == versionCode
                );
        }

        public async Task UpdateVersionLabel(string contentType, string contentId, string versionCode, string versionLabel)
        {
            var version = await GetVersionInfo(contentType, contentId, versionCode);

            if (version == null)
                throw new NullReferenceException("Cannot update version label. Version does not exist.");

            if (string.IsNullOrEmpty(versionLabel))
            {
                versionLabel = "Unlabeled Version";
            }

            version.VersionLabel = versionLabel;

            await _connectDb.SaveChangesAsync();
        }

        public async Task<ContentVersion> CreateDraftVersion(string contentType, string contentId, string userId, string versionLabel = null)
        {
            // Using default timestamp based version code generated by instance
            var version = new ContentVersion
            {
                ContentType = contentType,
                ContentId = contentId,
                VersionLabel = versionLabel,
                Created = DateTime.Now,
                Status = ContentStatus.Draft,
                UserId = userId
            };

            _connectDb.ContentVersions.Add(version);

            await _connectDb.SaveChangesAsync();

            return version;
        }

        public async Task SetVersionModelData(ContentVersion version, object data)
        {
            var entity = await GetVersionInfo(version.ContentType, version.ContentId, version.VersionCode);

            if (entity == null)
                throw new NullReferenceException("Cannot update version data. Version does not exist.");

            if (data == null)
            {
                entity.JsonData = null;
            }
            else
            {
                entity.JsonData = JsonConvert.SerializeObject(data, new JsonSerializerSettings
                {
                    ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
                    NullValueHandling = NullValueHandling.Include
                });
            }

            await _connectDb.SaveChangesAsync();
        }

        public TModel GetStoredData<TModel>(ContentVersion version)
        {
            if (version.JsonData == null)
                return default(TModel);

            return JsonConvert.DeserializeObject<TModel>(version.JsonData);
        }

        public async Task PublishDraftVersion(ContentVersion version)
        {
            await PublishDraftVersion(version.ContentType, version.ContentId, version.VersionCode);
        }

        public async Task PublishDraftVersion(string contentType, string contentId, string versionCode)
        {
            var toPublish = await GetVersionInfo(contentType, contentId, versionCode);
            if (toPublish.Status != ContentStatus.Draft)
                throw new InvalidOperationException("Only draft versions can be published");

            var oldPublished = await GetPublishedVersionInfo(contentType, contentId);
                     
            if(oldPublished != null)
            {
                oldPublished.Status = ContentStatus.Archived;
                _connectDb.Attach<ContentVersion>(oldPublished);
                _connectDb.Entry(oldPublished).State = Microsoft.EntityFrameworkCore.EntityState.Modified;
            }

            toPublish.Status = ContentStatus.Published;
           
            _connectDb.Attach<ContentVersion>(toPublish);
            _connectDb.Entry(toPublish).State = Microsoft.EntityFrameworkCore.EntityState.Modified;

            await _connectDb.SaveChangesAsync();
        }

        public async Task DeleteVersion(ContentVersion version)
        {
            await DeleteVersion(version.ContentType, version.ContentId, version.VersionCode);
        }

        public async Task DeleteVersion(string contentType, string contentId, string versionCode)
        {
            var version = await GetVersionInfo(contentType, contentId, versionCode);

            // TODO: Consider removing content tree here, rather than using a seperate method
            if (version != null)
            {
                _connectDb.ContentVersions.Remove(version);
                await _connectDb.SaveChangesAsync();
            }
        }

        public async Task DeleteAllVersions(string contentType, string contentId)
        {
            _connectDb.ContentVersions.RemoveRange
            (
                _connectDb.ContentVersions.Where
                (x => 
                    x.ContentType == contentType
                    && x.ContentId == contentId
                )
            );
            await _connectDb.SaveChangesAsync();
        }

        public async Task DeleteAllVersions(string contentType, string contentId, ContentStatus versionStatus)
        {
            _connectDb.ContentVersions.RemoveRange
            (
                _connectDb.ContentVersions.Where
                (x =>
                    x.ContentType == contentType
                    && x.ContentId == contentId
                    && x.Status == versionStatus
                )
            );
            await _connectDb.SaveChangesAsync();
        }

        public async Task<ContentTree> GetContentTree(string contentTreeId)
        {
            return await _connectDb.ContentTrees.FirstOrDefaultAsync(x => x.Id == contentTreeId);
        }

        public async Task<string> GetContentTreeId(ContentVersion version)
        {
            return await GetContentTreeId(version.ContentType, version.ContentId, version.VersionCode);
        }

        public async Task<string> GetContentTreeId(string contentType, string contentId, string versionCode = null)
        {
            var tree = await _connectDb.ContentTrees.FirstOrDefaultAsync(x =>
                 x.ContentType == contentType &&
                 x.ContentId == contentId &&
                 x.VersionCode == versionCode
            );

            return tree?.Id;
        }

        public async Task<string> GetContentTreeId( string contentId, string versionCode = null)
        {
            var tree = await _connectDb.ContentTrees.FirstOrDefaultAsync(x =>
                 x.ContentId == contentId &&
                 x.VersionCode == versionCode
            );

            return tree?.Id;
        }


        public async Task<IEnumerable<ContentNode>> GetContentNodes(string treeId)
        {
            return await _connectDb.ContentNodes.Where(x => x.ContentTreeId == treeId).ToListAsync();
        }

        public async Task<ContentTree> CreateContentTree(string contentType, string contentId, string versionCode = null)
        {
            var tree = new ContentTree
            {
                Id = Guid.NewGuid().ToString("N"),
                ContentId = contentId,
                ContentType = contentType,
                VersionCode = versionCode,
                ContentNodes = new List<ContentNode>()
            };

            _connectDb.ContentTrees.Add(tree);
            await _connectDb.SaveChangesAsync();

            return tree;
        }

        public async Task<ContentTree> CreateContentTree(ContentVersion info)
        {
            return await CreateContentTree(info.ContentType, info.ContentId, info.VersionCode);
        }

        public async Task<ContentTree> CloneContentTree(string treeId, string newVersionCode)
        {

            // Use No Tracking since we'll be inserting a new content tree, not updating the source
            var sourceTree = await _connectDb.ContentTrees
                .AsNoTracking()
                .Include(x => x.ContentNodes)
                .FirstOrDefaultAsync(x => x.Id == treeId);

            var sourceNodes = sourceTree.ContentNodes.ToList();
            var nodeKeyMap = new Dictionary<string, string>();

            if(sourceTree == null)
                throw new NullReferenceException($"Could not locate a record for version id: {treeId}");

            // Initialize the cloned tree
            var clonedTree = new ContentTree
            {
                Id = Guid.NewGuid().ToString("N"),
                ContentType = sourceTree.ContentType,
                ContentId = sourceTree.ContentId,
                VersionCode = newVersionCode,
                ContentNodes = new List<ContentNode>()
            };
                
            // Clone the content node structure
            foreach(var node in sourceNodes)
            {
                // Generate a new node key and track old id
                var newNodeId = Guid.NewGuid().ToString("N");

                nodeKeyMap.Add(node.Id, newNodeId);
                node.Id = newNodeId;

                // Instruct the underlying provider to clone a new content instance       
                var clonedWidget = _widgetProvider.CloneSettings(node.WidgetType, node.WidgetId);

                // Some content types have static or null models, thus return null clones. 
                // This is expected behavior and should result in a null mapping value
                node.WidgetId = clonedWidget?.Id; 
            }

            // 2nd pass (efficient) to update parent Ids using the node map
            foreach(var node in sourceNodes)
            {
                if (node.ParentId != null && nodeKeyMap.ContainsKey(node.ParentId))
                    node.ParentId = nodeKeyMap[node.ParentId];
            }

            clonedTree.ContentNodes.AddRange(sourceTree.ContentNodes);

            //TODO: Wrap in transaction to ensure data integrity
            _connectDb.ContentTrees.Add(clonedTree);

            await _connectDb.SaveChangesAsync();

            return clonedTree;
        }

        public async Task DeleteContentTree(string treeId)
        {
            var tree = await _connectDb.ContentTrees.FirstOrDefaultAsync(x => x.Id == treeId);

            if (tree != null)
            {
                _connectDb.ContentNodes.RemoveRange(
                    await _connectDb.ContentNodes.Where(x => x.ContentTreeId == tree.Id).ToListAsync()
                );

                _connectDb.ContentTrees.Remove(tree);
                await _connectDb.SaveChangesAsync();
            }
        }

        public async Task DeleteContentTree(ContentVersion version)
        {
            await DeleteContentTree(version.ContentType, version.ContentId, version.VersionCode);
        }

        public async Task DeleteContentTree(string contentType, string contentId, string versionCode)
        {
            var tree = await _connectDb.ContentTrees.FirstOrDefaultAsync(x =>
                x.ContentType == contentType
                && x.ContentId == contentId
                && x.VersionCode == versionCode
            );

            if (tree != null)
            {
                _connectDb.ContentNodes.RemoveRange(
                    await _connectDb.ContentNodes.Where(x => x.ContentTreeId == tree.Id).ToListAsync()
                );

                _connectDb.ContentTrees.Remove(tree);
                await _connectDb.SaveChangesAsync();
            }
        }

        public async Task DeleteAllContentTrees(string contentType, string contentId)
        {
            _connectDb.ContentNodes.RemoveRange(
                await _connectDb.ContentNodes.Where
                (x =>
                    x.ContentTree.ContentType == contentType
                    && x.ContentTree.ContentId == contentId
                ).ToListAsync()
            );

            _connectDb.ContentTrees.RemoveRange(
                await _connectDb.ContentTrees.Where
                (x =>
                    x.ContentType == contentType
                    && x.ContentId == contentId
                )
                .ToListAsync()
            );
            await _connectDb.SaveChangesAsync();
        }

        public async Task<ContentNode> GetContentNode(string nodeId)
        {
            return await _connectDb.ContentNodes.FirstOrDefaultAsync(x => x.Id == nodeId);
        }

        public async Task CreateContentNode(ContentNode node)
        {
            node.Id = Guid.NewGuid().ToString();

            //TODO: Add validation
            if (string.IsNullOrEmpty(node.CssColumnSize))
                node.CssColumnSize = "12";

            if(string.IsNullOrEmpty(node.ViewId) && !string.IsNullOrEmpty(node.WidgetType))
                node.ViewId = _widgetProvider.GetDefaultViewId(node.WidgetType);

            if (node.ParentId == null)
                node.SetStyle(ContentStyle.DefaultRootStyle);
            else
                node.SetStyle(ContentStyle.DefaultStyle);


            _connectDb.ContentNodes.Add(node);

            await _connectDb.SaveChangesAsync();
        }

        public async Task EnsureContentNodeModel(ContentNode node)
        {
            if (node.WidgetId == null)
            {
                // HACK: Having to intialize "null" models here because of 
                //       Several widgets who's models can't be exported / imported
                //       due to dependency on SiteContext.

                // TODO: Update all widgets so can be exported / imported properly 
                if (_widgetProvider.GetWidgetConfig(node.WidgetType).ModelType != null)
                {
                    node.WidgetId = _widgetProvider.Create(node.WidgetType).Id;
                    await UpdateContentNode(node);
                }
            }
        }

        public async Task UpdateContentNode(ContentNode node)
        {
            // TODO: Probably need to verify integrity of node data
            var entity = _connectDb.Entry<ContentNode>(node);

            if (node.Id == null || entity.State == EntityState.Added)
                throw new Exception("Cannot update a new ContentNode. Use Create instead.");

            if(node.Id != null && entity.State == EntityState.Detached)
            {
                entity.State = EntityState.Modified;
                _connectDb.ContentNodes.Attach(node);
            }

            if (entity.State == EntityState.Modified)
                await _connectDb.SaveChangesAsync();
        }

        public async Task UpdateNodePosition(string nodeId, string parentId, string zone, int index)
        {
            var node = await GetContentNode(nodeId);

            if (node != null)
            {
                node.ParentId = parentId;
                node.Zone = zone;
                node.Index = index;

                await _connectDb.SaveChangesAsync();
            }
        }

        public async Task UpdateNodeBackground(string nodeId, string value)
        {
            var node = await GetContentNode(nodeId);

            if (node != null)
            {
                var style = node.GetStyle();

                style.BackgroundClass = value;
                node.SetStyle(style);

                await _connectDb.SaveChangesAsync();
            }
        }

        public async Task UpdateNodeClasses(string nodeId, string value)
        {
            var node = await GetContentNode(nodeId);

            if (node != null)
            {
                var style = node.GetStyle();

                style.NodeClasses = value;
                node.SetStyle(style);

                await _connectDb.SaveChangesAsync();
            }
        }

        public async Task UpdateNodeFullWidth(string nodeId, bool value)
        {
            var node = await GetContentNode(nodeId);

            if (node != null)
            {
                var style = node.GetStyle();

                style.FullWidth = value;
                node.SetStyle(style);

                await _connectDb.SaveChangesAsync();
            }
        }

        public async Task UpdateNodePadding(string nodeId, string topValue, string bottomValue)
        {
            var node = await GetContentNode(nodeId);

            if (node != null)
            {
                var style = node.GetStyle();

                style.PaddingTop = topValue;
                style.PaddingBottom = bottomValue;

                node.SetStyle(style);

                await _connectDb.SaveChangesAsync();
            }
        }

        public async Task UpdateNodeMaxHeight(string nodeId, string value)
        {
            var node = await GetContentNode(nodeId);

            if (node != null)
            {
                var style = node.GetStyle();

                style.MaxHeight = value;
               
                node.SetStyle(style);

                await _connectDb.SaveChangesAsync();
            }
        }

        public async Task UpdateNodeAlignment(string nodeId, string value)
        {
            var node = await GetContentNode(nodeId);

            if (node != null)
            {
                var style = node.GetStyle();

                style.Alignment = value;

                node.SetStyle(style);

                await _connectDb.SaveChangesAsync();
            }
        }

        public async Task UpdateNodeSize(string nodeId, string size)
        {
            var node = await GetContentNode(nodeId);

            // TODO - add validation to ensure size is valid col-size or pct
            if (node != null)
            {
                node.CssColumnSize = size;

                await _connectDb.SaveChangesAsync();
            }
        }


        public ContentTreeBuilder CreateTreeBuilder(string contentTreeId)
        {
            var contentTree = GetContentTree(contentTreeId).Result;

            if (contentTree == null)
                throw new NullReferenceException($"Could not create ContentTreeBuilder: Invalid ContentTreeId {contentTreeId}");

            return new ContentTreeBuilder(_connectDb, _widgetProvider, contentTree);
        }

        public ContentTreeBuilder CreateTreeBuilder(ContentTree contentTree)
        {
            return new ContentTreeBuilder(_connectDb, _widgetProvider, contentTree);
        }

        public async Task DeleteContentNode(string nodeId)
        {
            var node = _connectDb.ContentNodes
                .Include(x => x.ChildNodes)
                .FirstOrDefault(x => x.Id == nodeId);

            await RecursiveDeleteContentNode(node);

            await _connectDb.SaveChangesAsync();
        }
     
      
        private async Task RecursiveDeleteContentNode(ContentNode parent)
        {
            if (parent.ChildNodes != null)
            {
                var children = await _connectDb.ContentNodes
                    .Include(x => x.ChildNodes)
                    .Where(x => x.ParentId == parent.Id)
                    .ToListAsync();

                foreach (var child in children)
                {
                    await RecursiveDeleteContentNode(child);
                }
            }

            _connectDb.ContentNodes.Remove(parent);
        }
    }
}
